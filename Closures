//é—­åŒ…çš„å½¢å¼
{(parameters) -> return type in
    statements
}
//ä¸¾ä¾‹
func test1(a: String, b: String) -> String {
    return a + b
}
test1(a: "will", b: "gong")

//è°ƒç”¨é—­åŒ…æ—¶ï¼Œä¸è¦ç”¨å¤–éƒ¨å‚æ•°åç§°a,b
let test2 = {(a: String, b: String) -> String in
    a + b
}
print(test2("will ","gong"))

//
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
var reversedNames = names.sorted(by: {(s1: String, s2: String) -> Bool in return s1 < s2
})
print(reversedNames)
//å‚æ•°ç¼©å†™$0 $1 $2
reversedNames = names.sorted(by: { $0 > $1 } )



//a closure is simply a function without a name, the type of a closure  is a function type.
var multipleClosure: (Int, Int) -> Int

//initial closure, a little bit different with function declaration.
var multipleClosure = {
    (a: Int, b: Int) -> Int in 
    return a*b
    } 
let result = multipleClosure(4,2)


// operateOnNumers(Int, Int, Int) -> Int
func operateOnNumbers(_ a: Int, _ b: Int, operation: (Int, Int) -> Int) -> Int
{
    let result = operation(a, b)
    print(result)
    return result
}
let addClosure = {
    (a: Int, b: Int) in
    a + b
}
operateOnNumbers(4, 2, operation: addClosure)

//trailing closure syntax
operateOnNumbers(4,2) {
    $0 + $1
}
//multiple trailing closure syntax
func sequenced(first: () -> void, second: () -> void) {
    first()
    second()
}
sequenced {
    print("Hello, ", terminator:"")
} second: {
    print("world.")
}

//
let names = ["ZZZZZZ", "BB", "A", "CCCC", "EEEEE"]
names.sorted()
names.sorted {
    $0.count > $1.count
}

//
let values = [1,2,3,4,5,6]
values.forEach {
    print("\($0): \($0*$0)")
}

//
var prices = [1.5, 10, 4.99, 2.30, 8.19]
let largePrices = prices.filter {
    $0 > 5
}

// map 
//trun them into an array
//[1.35, 9, 4.491000000000001, 2.07, 7.371]
var prices = [1.5, 10, 4.99, 2.30, 8.19]
let salePrices = prices.map {
    $0 * 0.9
}


//compactMap 
//create an array of Int and tosses out the missing values
//[0, 11, nil, 42]
let userInput = ["0", "11", "haha", "42"]
let numbers2 = userInput.map {
    Int($0)
}

//flateMap
// take them together
//["0", "1", "a", "b", "c", "ğŸ"]
let userInputNested = [["0", "1"], ["a", "b", "c"], ["ğŸ"]]
let allUserInput = userInputNested.flatMap {
    $0
}

//reduce
//
//15
var prices = [1, 2, 3, 4, 5]
let sum = prices.reduce(0) {
    $0 + $1
}
//dropFirst
//dropLast
//removeAll


//functions and closures
func greet(person: String) -> String {
    let greeting = "Hello " + person + "!"
    return greeting
}
print(greet(person: "Anna"))  //placing the value in the function
print(greet(person: "Brian")) //placing the value in the function

//æ— å‚æ•°å‡½æ•°
func sayHelloWorld() -> String {
    return "hello, world!"
}
print(sayHelloWorld())
//å¤šå‚æ•°å‡½æ•°
func greetAgain(person: String) -> String {
    return "Hello again, " + person + "!"
}
print(greetAgain(person: "Anna"))

func greet(person: String, alreadyGreated: Bool) -> String {
    if alreadyGreated {
        return greetAgain(person: person)
    } else
    {
        return greet(person: person)
    }
}
print(greet(person: "Tim", alreadyGreeted: true))
//æ— è¿”å›å€¼å‡½æ•°
func greet(person: String) {   //æ²¡æœ‰è¿”å›ç®­å¤´ï¼ˆ->ï¼‰å’Œè¿”å›ç±»å‹,å‡½æ•°ä¼šè¿”å›ä¸€ä¸ª Void ç±»å‹ç‰¹æ®Šå€¼ï¼Œè¯¥å€¼ä¸ºä¸€ä¸ªç©ºå…ƒç»„ï¼Œå†™æˆ ()
    print("Hello, \(person)!")
}
greet(person: "Dave") 
//å¤šè¿”å›å€¼å‡½æ•°
func minMax(array: [Int]) -> (min: Int, max: Int) {
    ...
    return (currentMin, currentMax)
}

//å¯é€‰å…ƒç»„è¿”å›ç±»å‹ (Int, Int)?  (Int?, Int?) 
func minMax(array: [Int]) -> (min: Int, max: Int)?  {
    ...
    return (currentMin, currentMax)
}
//nil

//éšå¼è¿”å›çš„å‡½æ•° çœç•¥return

//å‡½æ•°å‚æ•°æ ‡ç­¾ å¿½ç•¥å‚æ•°æ ‡ç­¾ï¼Œå¯ä»¥ç”¨ä¸‹åˆ’çº¿ï¼ˆ_ï¼‰æ¥ä»£æ›¿
//é»˜è®¤å‚æ•°å€¼
//å¯å˜å‚æ•° åœ¨å˜é‡ç±»å‹ååé¢åŠ å…¥ï¼ˆ...ï¼‰çš„æ–¹å¼æ¥å®šä¹‰å¯å˜å‚æ•°ã€‚
func arithmeticMean(_ numbers: Double...) -> Double {
    ...
}

//å¯ä»¥ä¿®æ”¹å‚æ•°çš„å€¼: è¾“å…¥è¾“å‡ºå‚æ•°ï¼ˆIn-Out Parametersï¼‰
//åŠ  inout å…³é”®å­—
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    ...
}
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
//å‡½æ•°æœ‰ä¸¤ä¸ªåˆ†åˆ«å«åš a å’Œ b çš„è¾“å…¥è¾“å‡ºå‚æ•°
//å‚æ•°å®šä¹‰åœ¨å‡½æ•°ä½“å¤–,éƒ½åŠ äº† & çš„å‰ç¼€

//
func stepForward(_ input: Int) -> Int {
    return input + 1
}

func stepBackward(_ input: Int) -> Int {
    return input - 1
}

func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return backward ? stepBackward : stepForward
} ////è¿”å›ç±»å‹æ˜¯ (Int) -> Int ç±»å‹çš„å‡½æ•°

var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
